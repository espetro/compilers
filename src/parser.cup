import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

action code {:
    // Code to be included in the action class - the one that parses the tokens (THESE RULES)
    String else_postpone_false_label = "";
    String else_new_label = "";
:};

parser code {:
    public void report_error(String message, Object info) {
        if(info instanceof Symbol) {
            Symbol curr = (Symbol)info;
            if(curr.left != -1 && curr.right != -1) {
                int line = curr.left + 1;
                int column = curr.right + 1;
                System.err.println(message + "(line " + line + ", column " + column + ")");
            }
        } else {
            System.err.println(message);
        }
        System.err.println(info);
    }
:};


// %%


terminal SEMI, PRINT, LPAREN, RPAREN, ASSIGN, LCURLY, RCURLY;  // TAB
terminal PLUS, MINUS, TIMES, MOD, DIV, UMINUS;
terminal EQ, NEQ, LT, GT, LE, GE;
terminal NOT, OR, AND, TRUE, FALSE;
terminal String IF, ELSE;
terminal Condition FOR, DO, WHILE;
terminal String ID, NUMBER;

nonterminal Object statement_list, stmt;
nonterminal Object else;
nonterminal String expr;
nonterminal Condition cond, logical;

// lowest priority
 precedence right ASSIGN;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left UMINUS;
precedence left AND, OR;
precedence left ELSE;
precedence right NOT;
// highest priority


// %%


statement_list ::= statement_list stmt
                   |
                   stmt
                   ;

stmt ::= expr SEMI
         {: /* done in 'expr' nonterminal */ :}
         |
         IF:tagIf LPAREN cond:c RPAREN {: Translator._label(c.TrueLabel()); :}
         stmt                          {: else_postpone_false_label = c.FalseLabel(); :}
         else                          {::}
         |
         WHILE:tagWhile LPAREN {: Translator._label(tagWhile.TrueLabel()); :}
         cond:c RPAREN         {: Translator._label(c.TrueLabel()); :}
         stmt                  {: Translator._goto(tagWhile.TrueLabel()); Translator._label(c.FalseLabel()); :}
         |
         DO:tagDo                             {: Translator._label(tagDo.TrueLabel()); :}
         stmt WHILE LPAREN cond:c RPAREN SEMI {:
            Translator._label(c.TrueLabel()); /* => */ Translator._goto(tagDo.TrueLabel());
            Translator._label(c.FalseLabel());
         :}
         |
         FOR:tagFor LPAREN expr:e1 SEMI {: Translator._label(tagFor.TrueLabel()); :}
         cond:c1 SEMI                   {: Translator._label(c1.TrueLabel()); :}
         expr:e2 RPAREN                 {::}
         stmt                           {: Translator._goto(tagFor.TrueLabel()); Translator._label(c1.FalseLabel()); :}
         |
         PRINT expr:e SEMI
         {: Translator._print(e); :}
         |
         LCURLY statement_list RCURLY
         {: /* done in the inner statement list */ :}
         ;

else ::= ELSE:tagElse  {:
            else_new_label = Translator.getNewLabel(); // creates a new label for exiting the whole statement
            Translator._goto(else_new_label);
            Translator._label(else_postpone_false_label);
         :}
         stmt          {: Translator._label(else_new_label); :}
         | /* empty */ {: Translator._label(else_postpone_false_label); :} // print the former conditional false label
         ;

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "+", e2); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "-", e2); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = Translator.arithmetic(e1, "*", e2); :}
         |
         expr:e1 DIV expr:e2
         {: RESULT = Translator.arithmetic(e1, "/", e2); :}
         |
         expr:e1 MOD expr:e2
         {: RESULT = Translator.arithmetic(e1, "%", e2); :}
         |
         MINUS expr:e
         {: RESULT = Translator.arithmetic("", "-", e); :}
         %prec UMINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         |
         ID:i ASSIGN expr:e
         {: RESULT = Translator.assignment(i, e); :}
         |
         ID:i
         {: RESULT = i; :}
         |
         NUMBER:n
         {: RESULT = n; :}
         ;

cond ::= expr:e1 EQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2); :}
         |
         expr:e1 NEQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.NEQ, e2); :}
         |
         expr:e1 LT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LT, e2); :}
         |
         expr:e1 GT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.GT, e2); :}
         |
         expr:e1 LE expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LE, e2); :}
         |
         expr:e1 GE expr:e2
         {: RESULT = Translator.comparison(e1, Translator.GE, e2); :}
         |
         LPAREN cond:c RPAREN
         {: RESULT = c; :}
         |
         logical:l
         {: RESULT = l; :}
         ;

logical ::= NOT cond:c
            {: c.permute(); RESULT = c; :}
            |
            cond:c1 AND {: Translator._label(c1.TrueLabel()); :}
            cond:c2     {:
                Translator._label(c1.FalseLabel());
                Translator._goto(c2.FalseLabel());
                RESULT = c2;
            :}
            |
            cond:c1 OR {: Translator._label(c1.FalseLabel()); :}
            cond:c2    {:
                Translator._label(c1.TrueLabel());
                Translator._goto(c2.TrueLabel());
                RESULT = c2;
            :}
            |
            TRUE
            {: RESULT = Translator.comparison("true", Translator.TRUE, ""); :}
            |
            FALSE
            {: RESULT = Translator.comparison("false", Translator.FALSE, ""); :}
            ;
