import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

// %%

terminal ASSIGN, INT, COLON, SEMI, PRINT, LPAREN, RPAREN, LCURLY, RCURLY, BREAK, ANPERSAN;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal EQ, NEQ, LT, GT, LE, GE;
terminal NOT, OR, AND;
terminal String IF, ELSE, DO, WHILE, QMARK, ELVIS, DEFAULT, CASE;
terminal Condition FOR;
terminal Switch SWITCH;
terminal String ID, NUMBER;

nonterminal Object statement_list, statement_list_opt, stmt, if_stmt, else_stmt, while_stmt, do_while_stmt, for_stmt;
nonterminal Object vardeclare, vartype, switch_case_stmt, default_opt, pointer_count;
nonterminal String expr, pointer_expr, ternary_op, elvis_op, break_opt;
nonterminal Condition cond, logical;
nonterminal Switch case_list;

/* PRIORITY LIST: Follows https://introcs.cs.princeton.edu/java/11precedence/ */

// lowest priority
precedence nonassoc IF;
precedence right QMARK;
precedence left EQ, NEQ;
precedence nonassoc LT, GT, GE, LE;
precedence right ASSIGN, ELVIS;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;
precedence left AND, OR;
precedence left ELSE;
precedence right NOT;
// highest priority


// %%


statement_list ::= statement_list stmt
                   |
                   stmt
                   ;

stmt ::= vartype vardeclare SEMI
         |
         expr SEMI
         |
         if_stmt
         |
         for_stmt
         |
         do_while_stmt
         |
         while_stmt
         |
         switch_case_stmt
         |
         PRINT expr:e SEMI
         {: Translator._print(e); :}
         |
         LCURLY statement_list RCURLY
         {: /* done in the inner statement list */ :}
         |
         error:e SEMI // handles errors while parsing (not recommended)
         {: Translator._errorTrace("CUP Error: error de sintaxis"); :}
         ;

// ================================================================
// =================== VARIABLE DECLARATION =======================

vartype ::= INT
            {: Variables.setCurrentType("int"); :}
            ;

vardeclare ::= ID:id
               {: Variables.declareVar(id); :}
               |
               pointer_count ID:id
               {:
                   Variables.declarePointer(id);
                   Variables.resetPointerLevel();
               :}
               ;

pointer_count ::= pointer_count TIMES
                  {: Variables.incPointerLevel(); :}
                  |
                  TIMES
                  {: Variables.incPointerLevel(); :}
                  ;

// ================================================================
// ======================= IF STATEMENT ===========================

if_stmt ::= IF:endIf LPAREN cond:c RPAREN
            {: Translator._label(c.TrueLabel()); :}
            stmt
            {:
               Translator._goto(endIf);
               Translator._label(c.FalseLabel());
            :}
            else_stmt
            {:
               Translator._goto(endIf);
               Translator._label(endIf);
            :}
            ;

else_stmt ::= ELSE stmt
              |
              // empty
              ;

// ================================================================
// ====================== WHILE STATEMENT =========================

while_stmt ::= WHILE:loopLabel LPAREN
               {: Translator._label(loopLabel); :}
               cond:c RPAREN
               {: Translator._label(c.TrueLabel()); :}
               stmt
               {:
                  Translator._goto(loopLabel);
                  Translator._label(c.FalseLabel());
               :}
               ;


do_while_stmt ::= DO:loopLabel
                  {: Translator._label(loopLabel); :}
                  stmt WHILE LPAREN cond:c RPAREN SEMI
                  {:
                     Translator._label(c.TrueLabel());
                     Translator._goto(loopLabel);
                     Translator._label(c.FalseLabel());
                  :}
                  ;

// ================================================================
// ======================= FOR STATEMENT ==========================

for_stmt ::= FOR:forLabel LPAREN expr SEMI
             // with TrueLabel we model the loop label
             {: Translator._label(forLabel.TrueLabel()); :}
             cond:c1 SEMI
             // with FalseLabel we model the modifier expression
             {: Translator._label(forLabel.FalseLabel()); :}
             expr RPAREN
             {:
                Translator._goto(forLabel.TrueLabel());
                Translator._label(c1.TrueLabel());
             :}
             stmt
             {:
                Translator._goto(forLabel.FalseLabel());
                Translator._label(c1.FalseLabel());
             :}
             ;

// ================================================================
// =================== SWITCH-CASE STATEMENT ======================

switch_case_stmt ::= case_list:cs
                     {: Translator._label(cs.getNextCaseLabel()); :}
                     default_opt RCURLY
                     {: Translator._label(cs.getEndLabel()); :}
                     ;

default_opt ::= DEFAULT COLON statement_list_opt
                |
                // empty
                ;

case_list ::= SWITCH:switchTag LPAREN expr:e1 RPAREN LCURLY
              CASE:caseTag expr:e2 COLON
              {:
                switchTag.setVarArg(e1);
                String switchCond = String.format("%s != %s", e1, e2);
                Translator._if(switchCond, caseTag);
              :}
              statement_list_opt break_opt:br
              {:
                switchTag.printGotoIfBreak(br);
                Translator._label(caseTag);
                RESULT = switchTag;
              :}
              |
              case_list:cs CASE:caseTag expr:e1 COLON
              {:
                String switchCond = String.format("%s != %s", cs.getVarArg(), e1);
                Translator._if(switchCond, caseTag); // jump the statement list (if any)
                Translator._label(cs.getNextCaseLabel()); // link to the previous "case"
              :}
              statement_list_opt break_opt:br
              {:
                cs.printGotoIfBreak(br);
                Translator._label(caseTag);
                RESULT = cs;
              :}
              ;

statement_list_opt ::= statement_list:ls
                       |
                       // empty
                       ;

break_opt ::= BREAK SEMI
              {: RESULT = "break"; :}
              |
              // empty
              {: RESULT = ""; :}
              ;

// ================================================================
// ======================== ARITHMETIC OPS ========================

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "+", e2); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "-", e2); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = Translator.arithmetic(e1, "*", e2); :}
         |
         expr:e1 DIV expr:e2
         {: RESULT = Translator.arithmetic(e1, "/", e2); :}
         |
         MINUS expr:e
         {: RESULT = Translator.arithmetic("0", "-", e); :}
         %prec UMINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         |
         ID:id ASSIGN expr:e
         {:
            if (!Variables.isValid(id)) { Translator._errorTrace("CUP Error: Variable no valida (ID = expr)"); }
            if (Variables.isDeref(e) && !Variables.isPointer(id)) {
                Translator._errorTrace("CUP Error: Una direccion de memoria solo se asigna a punteros (ID = expr)");
            }
            RESULT = Translator.assignment(id, e);
         :}
         |
         ternary_op:t
         {: RESULT = t; :}
         |
         elvis_op:e
         {: RESULT = e;:}
         |
         pointer_expr:pt
         {: RESULT = pt; :}
         |
         ID:id
         {:
            if(!Variables.isValid(id)) { Translator._errorTrace("CUP Error: Variable no valida (expr ::= ID)"); }
            RESULT = id;
         :}
         |
         NUMBER:n
         {: RESULT = n; :}
         ;

// ================================================================
// ======================== SPECIAL OPS ===========================

ternary_op ::= cond:c QMARK:ternaryLabel
               {:
                  RESULT = Translator.getNewTmpVar("int", false, false);
                  Translator._label(c.TrueLabel());
               :}
               expr:e1 COLON
               {:
                  Translator._applyAssign(RESULT, e1);
                  Translator._goto(ternaryLabel);
                  Translator._label(c.FalseLabel());
               :}
               expr:e2
               {:
                  Translator._applyAssign(RESULT, e2);
                  Translator._label(ternaryLabel);
               :}
               ;

elvis_op ::= expr:e1 ELVIS:elvisLabel
             {:
                 String _comparison = String.format("%s != 0", e1);
                 RESULT = Translator.getNewTmpVar("int", false, false);
                 Translator._applyAssign(RESULT, e1);
                 Translator._if(_comparison, elvisLabel); // if NEQ to 0, don't assign e2 to RESULT
             :}
             expr:e2
             {:
                Translator._applyAssign(RESULT, e2);
                Translator._label(elvisLabel);
             :}
             ;

// ================================================================
// ======================== COMPARISON OPS ========================

cond ::= expr:e1 EQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, false); :}
         |
         expr:e1 LT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LT, e2, false); :}
         |
         expr:e1 NEQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, true); :}
         |
         expr:e1 GT expr:e2
         {: RESULT = Translator.comparison(e2, Translator.LT, e1, false); :}
         |
         expr:e1 LE expr:e2
         {:
            Condition eq0 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq0.FalseLabel());
            Condition lt0 = Translator.comparison(e1, Translator.LT, e2, false);
            Translator._label(eq0.TrueLabel());
            Translator._goto(lt0.TrueLabel());
            RESULT = lt0;
         :}
         |
         expr:e1 GE expr:e2
         {:
            Condition eq1 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq1.FalseLabel());
            Condition lt1 = Translator.comparison(e2, Translator.LT, e1, false);
            Translator._label(eq1.TrueLabel());
            Translator._goto(lt1.TrueLabel());
            RESULT = lt1;
         :}
         |
         LPAREN cond:c RPAREN
         {: RESULT = c; :}
         |
         logical:l
         {: RESULT = l; :}
         ;

// ================================================================
// ======================== LOGICAL OPS ===========================

logical ::= NOT cond:c
            {: c.permute(); RESULT = c; :}
            |
            cond:c1 AND
            {: Translator._label(c1.TrueLabel()); :}
            cond:c2
            {:
                Translator._label(c1.FalseLabel());
                Translator._goto(c2.FalseLabel());
                RESULT = c2;
            :}
            |
            cond:c1 OR
            {: Translator._label(c1.FalseLabel()); :}
            cond:c2
            {:
                Translator._label(c1.TrueLabel());
                Translator._goto(c2.TrueLabel());
                RESULT = c2;
            :}
            ;

// ================================================================
// ====================== POINTER STATEMENTS ======================

/**
pointer_count ::= pointer_count TIMES
                  {: Variables.incPointerLevel(); :}
                  |
                  TIMES
                  {: Variables.incPointerLevel(); :}
                  ;
*/

pointer_expr ::= pointer_count ID:id ASSIGN expr:e // *p = 1 + 2;
                 {:
                     // The temporal variables are pointers iff the pointer level when assigning is >= 1
                     String tmp, res = id;

                     if (Variables.getPointerLevel() > 1) {
                         Variables.decPointerLevel(); // so it gets one less ptrLevel than ID
                         res = Translator.getNewTmpVar("int", true, false);
                         Translator._applyAssign(res, "*" + id);

                         while (Variables.getPointerLevel() > 1) {
                            Variables.decPointerLevel(); // so it gets one less ptrLevel than previous temp

                            tmp = Translator.getNewTmpVar("int", true, false);
                            Translator._applyAssign(tmp, "*" + res);
                            res = tmp;
                         }
                     }
                     Translator._applyAssign("*" + res, e);

                     Variables.resetPointerLevel();
                     RESULT = res;
                 :}
                 |
                 pointer_count ID:id // *p and more (eg ****p)
                 {:
                     // The temporal variables are pointers iff the pointer level when assigning is >= 1
                     // At least one temporal variable is created
                     String tmp, res;
                     Variables.decPointerLevel();

                     if (Variables.getPointerLevel() > 0) { // more than one assignment is done
                        res = Translator.getNewTmpVar("int", true, false);
                        Translator._applyAssign(res, "*" + id);

                        while(Variables.getPointerLevel() > 0) {
                            Variables.decPointerLevel();
                            tmp = Translator.getNewTmpVar("int", Variables.getPointerLevel() > 0, false);
                            Translator._applyAssign(tmp, "*" + res);
                            res = tmp;
                        }
                     } else { // just a single assignment is done
                        res = Translator.getNewTmpVar("int", false, false);
                        Translator._applyAssign(res, "*" + id);
                     }

                     // Always return a no-pointer
                     RESULT = res;
                 :}
                 |
                 ANPERSAN ID:id // this implicitly checks that '&' is only applied to variables
                 {:
                     Variables.incDerefLevel();
                     RESULT = Translator.getNewTmpVar("int", false, true);  // declares it as a level-1 deref temp
                     Variables.resetDerefLevel();

                     Translator._applyAssign(RESULT, "&" + id);
                 :}
                 ;
