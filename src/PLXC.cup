import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

// %%

terminal ASSIGN, SEMI, COMMA, PRINT, LPAREN, RPAREN, LCURLY, RCURLY, LBRACKET, RBRACKET, INT;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIV_ASSIGN;
terminal EQ, NEQ, LT, GT, LE, GE;
terminal NOT, OR, AND;
terminal String IF, ELSE, DO, WHILE;
terminal Condition FOR;
terminal String ID, NUMBER;

nonterminal Object statement_list, stmt, if_stmt, else_stmt, while_stmt, do_while_stmt, for_stmt, typedef, vardeclare;
nonterminal String expr, op_asign_expr, array_expr, array_init, init_list, init_list_elem, array_dims, array_accesses, var_init;
nonterminal Condition cond, logical;

// lowest priority
precedence left IF;
precedence right ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIV_ASSIGN;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS; // there's nothing at left of UMINUS
precedence left AND, OR;
precedence left ELSE;
precedence right NOT;
// highest priority


// %%


statement_list ::= statement_list stmt
                   |
                   stmt
                   ;

stmt ::= typedef vardeclare SEMI
         |
         expr SEMI
         |
         if_stmt
         |
         for_stmt
         |
         do_while_stmt
         |
         while_stmt
         |
         PRINT expr:e SEMI
         {: Translator._print(e); :}
         |
         LCURLY statement_list RCURLY
         {: /* done in the inner statement list */ :}
         |
         error:e SEMI
         {:
             Translator.logging.println("Error " + e);
             Translator._errorTrace("CUP Error: La sintaxis no es correcta");
         :}
         ;

// ================================================================
// ==================== VARIABLE DECLARE / INIT ===================

typedef ::= INT
            {: Variables.setCurrentType("int"); :}
            ;

vardeclare ::= ID:id var_init:var
               {:
                   Variables.declareVar(id);

                   if (var.length() > 0) {
                       Translator.assignment(id, var);
                   }
               :}
               |
               ID:id array_dims:arr_dims array_init:arr // arr is a list of temporal arrays (for ND) or expr (for 1D)
               {:
                   String[] dims = arr_dims.split(",");

                   // Translator.logging.println("dims are " + Variables.printArr(dims) + " and arr " + arr.length());

                   Variables.declareArray(id, dims);

                   if (arr.length() > 0) {
                       // Checks if the length and form of the input list matches (strictly equal) the array dims
                       // if it's right then it calls the Translator
                       String[] init = arr.split(",");
                       Variables.checkArrayAssign(id, init);
                   }
               :}
               ;

var_init ::= ASSIGN expr:e
             {: RESULT = e; :}
             |
             // empty
             {: RESULT = new String(); :}
             ;

// ================================================================
// ==================== ARRAY DECLARE / INIT ======================

array_dims ::= array_dims:ds LBRACKET NUMBER:n RBRACKET
               {: RESULT = ds + ","  + n; :}
               |
               LBRACKET NUMBER:n RBRACKET
               {: RESULT = n; :}
               ;

// Case 0: int a[1];
// Case 1: int a[2] = {1,2};
// Case 2: int a[2][2] = { {1,2}, {3,4} };
// Case 3: int a[2][2] = { {1}, {2} };
// Case 4: int a[2][2] = { {1,2}, {3} }; (ERROR)
// Case 5: int a[2][2] = { {1,2,3}, {4,5} }; (ERROR)
array_init ::= ASSIGN LCURLY init_list:ls RCURLY
               {: RESULT = ls; :}
               |
               // empty
               {: RESULT = new String(); :}
               ;

init_list ::= init_list:ls COMMA init_list_elem:el
              {:
                  boolean wrongArrInit = Variables.isArray(ls) && Variables.isArray(el) &&
                                         (Variables.getDims(ls) != Variables.getDims(el)) &&
                                         (Variables.getSize(ls) != Variables.getSize(el));
                  if (wrongArrInit) { // only if both are temporal arrays: check Cases 4 and 5
                      Translator._errorTrace("Inicializacion de array nD incorrecta");
                  }
                  RESULT = ls + "," + el;
              :}
              |
              init_list_elem:el
              {: RESULT = el; :}
              ;

init_list_elem ::= LCURLY init_list:ls RCURLY
                   {:
                       // Declares a temporal list to store inner array values
                       String[] init = ls.split(",");
                       String[] initLength = Variables.tmpArrSize(init); // if inner arrays are temporal arrays

                       RESULT = Variables.declareTempList("int", initLength);
                       Translator.logging.println(RESULT + " has dimensions " + Variables.printArr(initLength));
                       Variables.checkArrayAssign(RESULT, init);
                   :}
                   |
                   expr:e
                   {: RESULT = e; :}
                   ;

// ================================================================
// ======================= IF STATEMENT ===========================

if_stmt ::= IF:endIf LPAREN cond:c RPAREN
            {: Translator._label(c.TrueLabel()); :}
            stmt
            {:
               Translator._goto(endIf);
               Translator._label(c.FalseLabel());
            :}
            else_stmt
            {:
               Translator._goto(endIf);
               Translator._label(endIf);
            :}
            ;

else_stmt ::= ELSE stmt
              |
              // empty
              ;

// ================================================================
// ====================== WHILE STATEMENT =========================

while_stmt ::= WHILE:loopLabel LPAREN
               {: Translator._label(loopLabel); :}
               cond:c RPAREN
               {: Translator._label(c.TrueLabel()); :}
               stmt
               {:
                  Translator._goto(loopLabel);
                  Translator._label(c.FalseLabel());
               :}
               ;


do_while_stmt ::= DO:loopLabel
                  {: Translator._label(loopLabel); :}
                  stmt WHILE LPAREN cond:c RPAREN SEMI
                  {:
                     Translator._label(c.TrueLabel());
                     Translator._goto(loopLabel);
                     Translator._label(c.FalseLabel());
                  :}
                  ;

// ================================================================
// ======================= FOR STATEMENT ==========================

for_stmt ::= FOR:forLabel LPAREN expr SEMI
             // with TrueLabel we model the loop label
             {: Translator._label(forLabel.TrueLabel()); :}
             cond:c1 SEMI
             // with FalseLabel we model the modifier expression
             {: Translator._label(forLabel.FalseLabel()); :}
             expr RPAREN
             {:
                Translator._goto(forLabel.TrueLabel());
                Translator._label(c1.TrueLabel());
             :}
             stmt
             {:
                Translator._goto(forLabel.FalseLabel());
                Translator._label(c1.FalseLabel());
             :}
             ;


// ================================================================
// ======================== ARITHMETIC OPS ========================

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "+", e2, false); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "-", e2, false); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = Translator.arithmetic(e1, "*", e2, false); :}
         |
         expr:e1 DIV expr:e2
         {: RESULT = Translator.arithmetic(e1, "/", e2, false); :}
         |
         MINUS expr:e
         {: RESULT = Translator.arithmetic("0", "-", e, false); :}
         %prec UMINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         |
         ID:id ASSIGN expr:e
         {:
            Variables.checkID(id);

            if (Variables.isArray(id) && Variables.isArray(e)) {
                if (Variables.getSize(id) >= Variables.getSize(e)) {
                    Translator._copyArray(id, e);
                } else {
                    Translator._errorTrace("CUP Error: La capacidad de las listas no coinciden");
                }
            } else {
                Translator._applyAssign(id, e);
            }

            RESULT = id;
         :}
         |
         op_asign_expr:e
         {: RESULT = e; :}
         |
         array_expr:e
         {: RESULT = e; :}
         |
         ID:id
         {:
            Variables.checkID(id);
            RESULT = id;
         :}
         |
         NUMBER:n
         {: RESULT = n; :}
         ;

op_asign_expr ::= ID:id PLUS_ASSIGN expr:e
                  {:
                      Variables.checkID(id);
                      RESULT = Translator.arithmetic(id, "+", e, true);
                  :}
                  |
                  ID:id MINUS_ASSIGN expr:e
                  {:
                      Variables.checkID(id);
                      RESULT = Translator.arithmetic(id, "-", e, true);
                  :}
                  |
                  ID:id TIMES_ASSIGN expr:e
                  {:
                      Variables.checkID(id);
                      RESULT = Translator.arithmetic(id, "*", e, true);
                  :}
                  |
                  ID:id DIV_ASSIGN expr:e
                  {:
                      Variables.checkID(id);
                      RESULT = Translator.arithmetic(id, "/", e, true);
                  :}
                  ;

// ================================================================
// ======================== ARRAY/MATRIX OPS ======================

array_expr ::= ID:id array_accesses:access
               {:
                   Variables.checkID(id); // checked when an ID token is parsed
                   String[] dims = access.split(",");
                   String pos = Variables.checkArrayAccess(id, dims); // returns the computed position

                   RESULT = Variables.declareTemp("int");
                   Translator._applyAssign(RESULT, id + "[" + pos  + "]");
               :}
               |
               ID:id array_accesses:access ASSIGN expr:e2
               {:
                   Variables.checkID(id); // checked when an ID token is parsed
                   String[] dims = access.split(",");
                   String pos = Variables.checkArrayAccess(id, dims); // returns the computed position

                   Translator._applyAssign(id + "[" + pos + "]", e2);
                   RESULT = id;
               :}
               |
               ID:id ASSIGN LCURLY init_list:ls RCURLY
               {:
                    Variables.checkID(id);
                    String[] list = ls.split(",");
                    Variables.checkArrayAssign(id, list);
                    RESULT = id;
               :}
               ;

array_accesses ::= array_accesses:as LBRACKET expr:e RBRACKET
                   {: RESULT = as + "," + e; :}
                   |
                   LBRACKET expr:e RBRACKET
                   {: RESULT = e; :}
                   ;

// ================================================================
// ======================== COMPARISON OPS ========================

cond ::= expr:e1 EQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, false); :}
         |
         expr:e1 LT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LT, e2, false); :}
         |
         expr:e1 NEQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, true); :}
         |
         expr:e1 GT expr:e2
         {: RESULT = Translator.comparison(e2, Translator.LT, e1, false); :}
         |
         expr:e1 LE expr:e2
         {:
            Condition eq0 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq0.FalseLabel());
            Condition lt0 = Translator.comparison(e1, Translator.LT, e2, false);
            Translator._label(eq0.TrueLabel());
            Translator._goto(lt0.TrueLabel());
            RESULT = lt0;
         :}
         |
         expr:e1 GE expr:e2
         {:
            Condition eq1 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq1.FalseLabel());
            Condition lt1 = Translator.comparison(e2, Translator.LT, e1, false);
            Translator._label(eq1.TrueLabel());
            Translator._goto(lt1.TrueLabel());
            RESULT = lt1;
         :}
         |
         LPAREN cond:c RPAREN
         {: RESULT = c; :}
         |
         logical:l
         {: RESULT = l; :}
         ;

// ================================================================
// ======================== LOGICAL OPS ===========================

logical ::= NOT cond:c
            {: c.permute(); RESULT = c; :}
            |
            cond:c1 AND
            {: Translator._label(c1.TrueLabel()); :}
            cond:c2
            {:
                Translator._label(c1.FalseLabel());
                Translator._goto(c2.FalseLabel());
                RESULT = c2;
            :}
            |
            cond:c1 OR
            {: Translator._label(c1.FalseLabel()); :}
            cond:c2
            {:
                Translator._label(c1.TrueLabel());
                Translator._goto(c2.TrueLabel());
                RESULT = c2;
            :}
            ;
