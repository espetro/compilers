import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

// %%

terminal ASSIGN, COMMA, IN, SEMI, PRINT, LPAREN, RPAREN, LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal INT, FLOAT, INT_CAST, FLOAT_CAST;
terminal EQ, NEQ, LT, GT, LE, GE;
terminal NOT, OR, AND;
terminal String IF, ELSE, DO, WHILE;
terminal Condition FOR;
terminal String ID, INUMBER, FNUMBER;

nonterminal statement_list, stmt, if_stmt, else_stmt, while_stmt, do_while_stmt, for_stmt;
nonterminal vartype, var_declare;
nonterminal String expr, array_init, init_list, for_in_iter, for_in_arr;
nonterminal Condition cond, logical, for_in_stmt;

// lowest priority
precedence left IF;
precedence right ASSIGN;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right INT_CAST, FLOAT_CAST;
precedence left UMINUS; // there's nothing at left of UMINUS
precedence left AND, OR;
precedence left ELSE;
precedence right NOT;
// highest priority


// %%


statement_list ::= statement_list stmt
                   |
                   stmt
                   ;

stmt ::= vartype var_declare SEMI
         |
         expr SEMI
         |
         if_stmt
         |
         for_stmt
         |
         for_in_stmt
         |
         do_while_stmt
         |
         while_stmt
         |
         PRINT expr:e SEMI
         {: Translator.print(e); :}
         |
         LCURLY statement_list RCURLY
         {: /* done in the inner statement list */ :}
         |
         error SEMI
         {: Translator._errorTrace("CUP Error: Sintaxis no correcta"); :}
         ;

vartype ::= INT
            {: Variables.setCurrentType("int"); :}
            |
            FLOAT
            {: Variables.setCurrentType("float"); :}
            ;

var_declare ::= ID:id
                {: Variables.declareVar(id, "0"); :}
                |
                ID:id LBRACKET INUMBER:n RBRACKET array_init:arr
                {:
                    Variables.declareVar(id, n);
                    String[] init_list = arr.split(",");
                    int m = Integer.parseInt(n);

                    if (!(init_list[0] == "")) { // only if array_init is empty in CUP
                        if (m == init_list.length) { // at declaration, lengths have to be strictly the same
                            String arr_type = Variables.getType(id);
                            String t0 = Translator.getNewTmpVar(), t1 = Translator.getNewTmpVar();
                            // Variables.declareTempVar(t0, "0", "int");
                            // Variables.declareTempVar(t1, "0", "int");
                            for(int i = 0; i < init_list.length; i++) {
                                if(arr_type != Translator.getType(init_list[i])) {
                                    Translator._errorTrace("CUP Error: error de tipos (TYPE ID = { ... }");
                                }

                                String _t0 = String.format("%s[%s]", t0, i);
                                String _id = String.format("%s[%s]", id, i);
                                Translator._applyAssign(_t0, init_list[i]);
                                Translator._applyAssign(t1, _t0);
                                Translator._applyAssign(_id, t1);
                            }
                        } else {
                            Translator._errorTrace("CUP Error: var_declare");
                        }
                    }
                :}
                ;

array_init ::= ASSIGN LCURLY init_list:ls RCURLY
               {: RESULT = ls; :}
               |
               // empty - at least the init list has length 1 (so we can check [0])
               {: RESULT = ""; :}
               ;

init_list ::= init_list:ls COMMA expr:e
              {: RESULT = ls + "," + e; :}
              |
              expr:e
              {: RESULT = e; :}
              ;

// ================================================================
// ======================= IF STATEMENT ===========================

if_stmt ::= IF:endIf LPAREN cond:c RPAREN
            {: Translator._label(c.TrueLabel()); :}
            stmt
            {:
               Translator._goto(endIf);
               Translator._label(c.FalseLabel());
            :}
            else_stmt
            {:
               Translator._goto(endIf);
               Translator._label(endIf);
            :}
            ;

else_stmt ::= ELSE stmt
              |
              // empty
              ;

// ================================================================
// ====================== WHILE STATEMENT =========================

while_stmt ::= WHILE:loopLabel LPAREN
               {: Translator._label(loopLabel); :}
               cond:c RPAREN
               {: Translator._label(c.TrueLabel()); :}
               stmt
               {:
                  Translator._goto(loopLabel);
                  Translator._label(c.FalseLabel());
               :}
               ;


do_while_stmt ::= DO:loopLabel
                  {: Translator._label(loopLabel); :}
                  stmt WHILE LPAREN cond:c RPAREN SEMI
                  {:
                     Translator._label(c.TrueLabel());
                     Translator._goto(loopLabel);
                     Translator._label(c.FalseLabel());
                  :}
                  ;

// ================================================================
// ======================= FOR STATEMENT ==========================

for_stmt ::= FOR:forLabel LPAREN expr SEMI
             // with TrueLabel we model the loop label
             {: Translator._label(forLabel.TrueLabel()); :}
             cond:c1 SEMI
             // with FalseLabel we model the modifier expression
             {: Translator._label(forLabel.FalseLabel()); :}
             expr RPAREN
             {:
                Translator._goto(forLabel.TrueLabel());
                Translator._label(c1.TrueLabel());
             :}
             stmt
             {:
                Translator._goto(forLabel.FalseLabel());
                Translator._label(c1.FalseLabel());
             :}
             ;



for_in_stmt ::= FOR:forLabel for_in_iter:it IN for_in_arr:arr
                {:
                    if (Translator.isValid(it) && Translator.isValid(arr) && Variables.isArray(arr)) {
                        String _it = Translator.isArrayElement(it) ? String.valueOf(it.charAt(0)) : it;
                        if (Variables.getType(_it) == Variables.getType(arr)) {

                            String _idx = Translator.getNewTmpVar();
                            Variables.declareTempVar(_idx, "0", "int");
                            Translator.assignment(_idx, "0");

                            String _size = Translator.getNewTmpVar(), _arr_size = String.valueOf(Variables.getSize(arr));
                            Variables.declareTempVar(_size, "0", "int");
                            Translator.assignment(_size, _arr_size);

                            Translator._label(forLabel.TrueLabel()); // The label for the loop
                            RESULT = Translator.comparison(_idx, Translator.LT, _size, false);

                            Translator._label(forLabel.FalseLabel());
                            String t1 = Translator.arithmetic(_idx, "+", "1");
                            Translator._applyAssign(_idx, t1);
                            Translator._goto(forLabel.TrueLabel());

                            Translator._label(RESULT.TrueLabel());
                            String value = String.format("%s[%s]", arr, _idx);

                            // HERE IS THE IMPORTANT ASSIGNMENT
                            String t0 = Translator.getNewTmpVar(); // useful when using b[i] as it
                            Variables.declareTempVar(t0, "0", Variables.getType(arr));
                            Translator._applyAssign(t0, value);
                            Translator._applyAssign(it, t0);

                            // stmt
                        } else {
                            Translator._errorTrace("CUP Error: error de tipos (for_in_stmt)");
                        }
                    } else {
                        String unsafeVar = Translator.isValid(it) ? "arr" : "it";
                        Translator._errorTrace("CUP Error: Variable '" + unsafeVar + "' no valida (for_in_stmt)");
                    }
                :}
                DO stmt
                {:
                    Translator._goto(forLabel.FalseLabel());
                    Translator._label(RESULT.FalseLabel());
                :}
                ;

for_in_iter ::= ID:id
                {: RESULT = id; :}
                |
                ID:id LBRACKET expr:e RBRACKET
                {: RESULT = String.format("%s[%s]", id, e); :}
                ;

for_in_arr ::= ID:id
               {: RESULT = id; :}
               |
               LCURLY init_list:ls RCURLY
               {:
                  String[] arr = ls.split(",");
                  String curr_type = Translator.getType(arr[0]);
                  RESULT = Translator.getNewTmpVar();

                  for (int i = 0; i < arr.length; i++) {
                      if(curr_type != Translator.getType(arr[i])) {
                          Translator._errorTrace("CUP Error: error de tipos (for_in_arr init_list)");
                      }
                      String _result = String.format("%s[%s]", RESULT, i);
                      Translator._applyAssign(_result, arr[i]);
                  }
                  // Declares the variable as an array of type CURR_TYPE
                  Variables.setCurrentType(curr_type);
                  Variables.declareVar(RESULT, String.valueOf(arr.length));
               :}
               ;

// ================================================================
// ======================== ARITHMETIC OPS ========================

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "+", e2); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "-", e2); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = Translator.arithmetic(e1, "*", e2); :}
         |
         expr:e1 DIV expr:e2
         {: RESULT = Translator.arithmetic(e1, "/", e2); :}
         |
         MINUS expr:e
         {: RESULT = Translator.arithmetic("0", "-", e); :}
         %prec UMINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         |
         INT_CAST expr:e
         {:
            RESULT = Translator.getNewTmpVar();
            Variables.declareTempVar(RESULT, "0", "int");
            Translator._applyCastedAssign(RESULT, "(int)", e);
         :}
         |
         FLOAT_CAST expr:e
         {:
            RESULT = Translator.getNewTmpVar();
            Variables.declareTempVar(RESULT, "0", "float");
            Translator._applyCastedAssign(RESULT, "(float)", e);
         :}
         |
         ID:id ASSIGN expr:e
         {:
            if(!Translator.isValid(id)) { Translator._errorTrace("CUP Error: Variable no declarada"); }

            if (Variables.isArray(id) && Variables.isVariable(e) && Variables.isArray(e)) {
                // ============= COPY ARRAY =============
                boolean validSize = Variables.getSize(id) >= Variables.getSize(e);
                boolean validType = Variables.getType(id) == Variables.getType(e);
                if (validSize && validType) {
                    String t0 = Translator.getNewTmpVar();
                    int len = Variables.getSize(e);
                    for(int i = 0; i < len; i++) {
                        String _e = String.format("%s[%s]", e, i), _id = String.format("%s[%s]", id, i);
                        Translator._applyAssign(t0, _e);
                        Translator._applyAssign(_id, t0);
                    }
                } else {
                    if(!validType) { Translator._errorTrace("CUP Error: Las matrices no son compatibles en tipo"); }
                    else { Translator._errorTrace("CUP Error: Las matrices no son compatibles en espacio"); }
                }
            } else {
                Translator.assignment(id, e);
            }

            RESULT = id;
         :}
         |
         ID:id ASSIGN LCURLY init_list:ls RCURLY
         {:
            if(!Translator.isValid(id)) { Translator._errorTrace("CUP Error: Variable no declarada"); }

            String[] init_list = ls.split(",");
            int m = Variables.getSize(id);

            if (init_list[0] != "") { // only if array_init is empty in CUP
                if (m >= init_list.length) {
                    String arr_type = Variables.getType(id);
                    String t0 = Translator.getNewTmpVar(), t1 = Translator.getNewTmpVar();
                    // Variables.declareTempVar(t0, "0", "int");
                    // Variables.declareTempVar(t1, "0", "int");
                    for(int i = 0; i < init_list.length; i++) {
                        if(arr_type != Translator.getType(init_list[i])) {
                            Translator._errorTrace("CUP Error: error de tipos (ID = { ... }");
                        }
                        String _t0 = String.format("%s[%s]", t0, i);
                        String _id = String.format("%s[%s]", id, i);
                        Translator._applyAssign(_t0, init_list[i]);
                        Translator._applyAssign(t1, _t0);
                        Translator._applyAssign(_id, t1);
                    }
                } else {
                    Translator._errorTrace("CUP Error: ID = { init_list } ");
                }
            }

            RESULT = id;
         :}
         |
         ID:id LBRACKET expr:e1 RBRACKET ASSIGN expr:e2
         {:
            if(!Translator.isValid(id)) { Translator._errorTrace("CUP Error: Variable no declarada"); }

            // As expr can also be an INUMBER, check it
            if (Translator.isIntConst(e1)) {
                int m = Integer.parseInt(e1);
                if (m >= Variables.getSize(id)) { Translator._errorTrace("CUP Error: ArrayIndexOutOfBoundsException (1)"); }
            } else {
                // IF ASSIGNMENT TYPES ARE NOT THE SAME
                if (Variables.getType(id) != Translator.getType(e2)) {
                    Translator._errorTrace("CUP Error: error de tipos (ID[..] = ...)");
                }
                Condition _rangeCheck = new Condition();
                String o1 = String.format("%s < 0", e1),
                       o2 = String.format("%s < %s", Variables.getSize(id), e1),
                       o3 = String.format("%s == %s", Variables.getSize(id), e1);

                Translator._comment("Comprobacion de rango");
                Translator._if(o1, _rangeCheck.TrueLabel());
                Translator._if(o2, _rangeCheck.TrueLabel());
                Translator._if(o3, _rangeCheck.TrueLabel());
                Translator._goto(_rangeCheck.FalseLabel());

                Translator._label(_rangeCheck.TrueLabel());
                Translator._error();
                Translator._halt();
                Translator._label(_rangeCheck.FalseLabel());
            }

            RESULT = Translator.assignment2Array(id, e1, e2);
         :}
         |
         ID:id
         {:
            if(!Translator.isValid(id)) { Translator._errorTrace("CUP Error: Variable no declarada"); }
            RESULT = id;
         :}
         |
         ID:id LBRACKET expr:e RBRACKET
         {:
            // ONE WAY IT'D BE TO DO THE TEMPORAL ASSIGN IN THE OPERATIONS THAT ONLY NEED IT
            // eg in the FOR b[i] IN .. DO, we dont need it to be assigned to t2 => instead just return b[i]

            if(!Translator.isValid(id)) { Translator._errorTrace("CUP Error: Variable no declarada"); }

            if(Translator.isIntConst(e)) {
                int m = Integer.parseInt(e);
                if (m >= Variables.getSize(id)) { Translator._errorTrace("CUP Error: ArrayIndexOutOfBoundsException (2)"); }
            } else {
                Condition _rangeCheck = new Condition();
                String o1 = String.format("%s < 0", e),
                       o2 = String.format("%d < %s", Variables.getSize(id), e),
                       o3 = String.format("%d == %s", Variables.getSize(id), e);

                Translator._comment("Comprobacion de rango");
                Translator._if(o1, _rangeCheck.TrueLabel());
                Translator._if(o2, _rangeCheck.TrueLabel());
                Translator._if(o3, _rangeCheck.TrueLabel());
                Translator._goto(_rangeCheck.FalseLabel());

                Translator._label(_rangeCheck.TrueLabel());
                Translator._error();
                Translator._halt();
                Translator._label(_rangeCheck.FalseLabel());
            }

            String _id = String.format("%s[%s]", id, e);
            String _id_type = Variables.getType(id);
            RESULT = Translator.getNewTmpVar();

            Variables.declareTempVar(RESULT, "0", _id_type);
            Translator._applyAssign(RESULT, _id);
         :}
         |
         INUMBER:n
         {: RESULT = n; :}
         |
         FNUMBER:f
         {: RESULT = f; :}
         ;

// ================================================================
// ======================== COMPARISON OPS ========================

cond ::= expr:e1 EQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, false); :}
         |
         expr:e1 LT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LT, e2, false); :}
         |
         expr:e1 NEQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, true); :}
         |
         expr:e1 GT expr:e2
         {: RESULT = Translator.comparison(e2, Translator.LT, e1, false); :}
         |
         expr:e1 LE expr:e2
         {:
            Condition eq0 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq0.FalseLabel());
            Condition lt0 = Translator.comparison(e1, Translator.LT, e2, false);
            Translator._label(eq0.TrueLabel());
            Translator._goto(lt0.TrueLabel());
            RESULT = lt0;
         :}
         |
         expr:e1 GE expr:e2
         {:
            Condition eq1 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq1.FalseLabel());
            Condition lt1 = Translator.comparison(e2, Translator.LT, e1, false);
            Translator._label(eq1.TrueLabel());
            Translator._goto(lt1.TrueLabel());
            RESULT = lt1;
         :}
         |
         LPAREN cond:c RPAREN
         {: RESULT = c; :}
         |
         logical:l
         {: RESULT = l; :}
         ;

// ================================================================
// ======================== LOGICAL OPS ===========================

logical ::= NOT cond:c
            {: c.permute(); RESULT = c; :}
            |
            cond:c1 AND
            {: Translator._label(c1.TrueLabel()); :}
            cond:c2
            {:
                Translator._label(c1.FalseLabel());
                Translator._goto(c2.FalseLabel());
                RESULT = c2;
            :}
            |
            cond:c1 OR
            {: Translator._label(c1.FalseLabel()); :}
            cond:c2
            {:
                Translator._label(c1.TrueLabel());
                Translator._goto(c2.TrueLabel());
                RESULT = c2;
            :}
            ;

// ================================================================
// ======================== ARRAYS ================================


