import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

// %%

terminal ASSIGN, INT, CHAR, SEMI, COMMA, PRINT, LPAREN, RPAREN, LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal LENGTH_PROP, INT_CAST, CHAR_CAST, TILDE, PLUS, MINUS, TIMES, DIV, UMINUS;
terminal EQ, NEQ, LT, GT, LE, GE;
terminal NOT, OR, AND;
terminal String IF, ELSE, DO, WHILE;
terminal Condition FOR;
terminal String ID, CHAR_CONST, NUMBER;

nonterminal program, statement_list, stmt, vardeclare, vartype, if_stmt, else_stmt, while_stmt, do_while_stmt, for_stmt;
nonterminal String expr, typecast, tilded_expr, array_expr, varinit, vardims, init_list;
nonterminal Condition cond, logical;

// lowest priority
precedence left IF;
precedence right ASSIGN;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left AND, OR;
precedence right NOT, TILDE, UMINUS, INT_CAST, CHAR_CAST; // all unary operators (NOT = TILDE_MAX for chars)
precedence nonassoc IF, ELSE;
// highest priority


// %%

// Beware: I'm dealing with chars by keeping the single quotes; this way I don't have to change anything on the compiler
// structure (everything is a String, but only chars contain \' symbols).
// I DO ALL CHECKS ON TRANSLATOR CLASS but I don't have to rewrite some stuff on here :D
// Another valuable way would be to create a NONTERMINAL for character and process it from "statement_list"; only the
// char (+, -) operations would be under "expr" (as they return an int).

program ::= statement_list
            |
            // empty
            {: Translator._comment("Entrada vacia"); :}
            ;

statement_list ::= statement_list stmt
                   |
                   stmt
                   ;

stmt ::= vartype vardeclare SEMI
         |
         expr SEMI
         |
         if_stmt
         |
         for_stmt
         |
         do_while_stmt
         |
         while_stmt
         |
         PRINT expr:e SEMI
         {: Translator.print(e); :}
         |
         LCURLY statement_list RCURLY
         {: /* done in the inner statement list */ :}
         ;

         /**
         |
         error:e SEMI // handles errors while parsing (not recommended)
         {: :}
         ;
         */

// ================================================================
// =================== VARIABLE / ARRAY DECLARE ===================

vartype ::= CHAR
            {: Variables.setCurrentType("char"); :}
            |
            INT
            {: Variables.setCurrentType("int"); :}
            ;

vardeclare ::= vardeclare:dec COMMA ID:id vardims:dims varinit:value
               {:
                   Variables.declareVar(id, dims);

                   if (value.length() > 0) {
                       // Case 1: The variable is initialized right away
                       if (dims.length() > 0) {
                           // Case 1.1: The variable is an array
                           Arrays.init(id, value);
                       } else {
                           Translator.assignment(id, value);
                       }
                   }
               :}
               |
               ID:id vardims:dims varinit:value
               {:
                   Variables.declareVar(id, dims);

                   if (value.length() > 0) {
                       // Case 1: The variable is initialized right away
                       if (dims.length() > 0) {
                           // Case 1.1: The variable is an array
                           Arrays.init(id, value);
                       } else {
                           Translator.assignment(id, value);
                       }
                   }
               :}
               ;

vardims ::= LBRACKET NUMBER:n RBRACKET
            {: RESULT = n; :}
            |
            // empty
            {: RESULT = new String(); :}
            ;

varinit ::= ASSIGN expr:e
            {: RESULT = e; :}
            |
            ASSIGN LCURLY init_list:ls RCURLY
            {: RESULT = ls; :}
            |
            // empty
            {: RESULT = new String(); :}
            ;

init_list ::= init_list:ls COMMA expr:e
              {: RESULT = ls + "," + e; :}
              |
              expr:e
              {: RESULT = e; :}
              ;

// ================================================================
// ======================= IF STATEMENT ===========================

if_stmt ::= IF:endIf LPAREN cond:c RPAREN
            {: Translator._label(c.TrueLabel()); :}
            stmt
            {:
               Translator._goto(endIf);
               Translator._label(c.FalseLabel());
            :}
            else_stmt
            {:
               Translator._goto(endIf);
               Translator._label(endIf);
            :}
            ;

else_stmt ::= ELSE stmt
              |
              // empty
              ;

// ================================================================
// ====================== WHILE STATEMENT =========================

while_stmt ::= WHILE:loopLabel LPAREN
               {: Translator._label(loopLabel); :}
               cond:c RPAREN
               {: Translator._label(c.TrueLabel()); :}
               stmt
               {:
                  Translator._goto(loopLabel);
                  Translator._label(c.FalseLabel());
               :}
               ;


do_while_stmt ::= DO:loopLabel
                  {: Translator._label(loopLabel); :}
                  stmt WHILE LPAREN cond:c RPAREN SEMI
                  {:
                     Translator._label(c.TrueLabel());
                     Translator._goto(loopLabel);
                     Translator._label(c.FalseLabel());
                  :}
                  ;

// ================================================================
// ======================= FOR STATEMENT ==========================

for_stmt ::= FOR:forLabel LPAREN expr SEMI
             // with TrueLabel we model the loop label
             {: Translator._label(forLabel.TrueLabel()); :}
             cond:c1 SEMI
             // with FalseLabel we model the modifier expression
             {: Translator._label(forLabel.FalseLabel()); :}
             expr RPAREN
             {:
                Translator._goto(forLabel.TrueLabel());
                Translator._label(c1.TrueLabel());
             :}
             stmt
             {:
                Translator._goto(forLabel.FalseLabel());
                Translator._label(c1.FalseLabel());
             :}
             ;


// ================================================================
// ======================== ARITHMETIC OPS ========================

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "+", e2); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "-", e2); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = Translator.arithmetic(e1, "*", e2); :}
         |
         expr:e1 DIV expr:e2
         {: RESULT = Translator.arithmetic(e1, "/", e2); :}
         |
         MINUS expr:e
         {: RESULT = Translator.arithmetic("0", "-", e); :}
         %prec UMINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         |
         ID:id ASSIGN expr:e
         {:
             Variables.checkVar(id);
             RESULT = id;

             if (Variables.isArray(id) && Variables.isArray(e)) {
                 Arrays.copy(id, e);
             } else {
                 Translator.assignment(id, e);
             }

         :}
         |
         ID:id
         {:
             Variables.checkVar(id);  // confirms if the variable that it's being called is declared
             RESULT = id;
         :}
         |
         CHAR_CONST:id
         {: RESULT = id; :} // All have single quotes
         |
         NUMBER:n
         {: RESULT = n; :} // None have single quotes
         |
         typecast:casted
         {: RESULT = casted; :}
         |
         tilded_expr:e
         {: RESULT = e; :}
         |
         array_expr:arr
         {: RESULT = arr; :}
         ;

// ================================================================
// ========================= TYPECASTING ==========================

typecast ::= INT_CAST expr:e
             {:
                 // WARNING!! THIS IS A HOTFIX FOR char10.plx (WHY THERE'S NO CONVERSION FOR char Variables????
                 if (Variables.getType(e) == "char" && !Variables.isDeclared(e)) {
                     RESULT = Char.toInt(e);
                 } else {
                     RESULT = e;
                 }
             :}
             |
             CHAR_CAST expr:e
             {:
                 // WARNING!! THIS IS A HOTFIX FOR char10.plx (WHY THERE'S NO CONVERSION FOR int Variables????
                 if (Variables.getType(e) == "char" || Variables.isDeclared(e)) {
                     RESULT = e;
                 } else {
                     RESULT = Char.fromInt(e);
                 }
             :}
             ;

// ================================================================
// ======================= CHAR OPERATIONS ========================

tilded_expr ::= TILDE expr:e // ~'a' or ~var1
                {:
                    String t0 = Translator.getNewTmpVar("char");
                    Condition cond = new Condition();

                    Translator.assignment(t0, e);

                    if (Variables.isChar(e) && !Variables.isDeclared(e)) {
                        e = Char.toInt(e);
                    }

                    Translator._if(e + " < 65", cond.TrueLabel()); // no es alfabetico
                    Translator._if("122 < " + e, cond.TrueLabel()); // no es alfabetico
                    Translator._if("96 < " + e, cond.FalseLabel()); // es minuscula => a Mayuscula
                    Translator._if("90 < " + e, cond.TrueLabel()); // no es alfabetico

                    Translator._applyOp(t0, e, "+", "32"); // es mayuscula => a Minuscula
                    Translator._goto(cond.FalseLabel());

                    Translator._label(cond.FalseLabel());
                    Translator._applyOp(t0, e, "-", "32");
                    Translator._label(cond.TrueLabel());

                    RESULT = t0;
                :}
                |
                NOT expr:e // !'a' or !var1
                {:
                    String t0 = Translator.getNewTmpVar("char");
                    String outLabel = Translator.getNewLabel();

                    Translator.assignment(t0, e);

                    if (Variables.isChar(e) && !Variables.isDeclared(e)) {
                        e = Char.toInt(e);
                    }

                    // If its not a Lowercase, go out
                    Translator._if(String.format("%s < 97", e), outLabel);
                    Translator._if(String.format("122 < %s", e), outLabel);
                    Translator._applyOp(t0, e, "-", "32");

                    Translator._label(outLabel);

                    RESULT = t0;
                :}
                ;

// ================================================================
// ====================== ARRAY EXPRESSIONS =======================

array_expr ::= ID:id LBRACKET expr:e RBRACKET
               {:
                   Variables.checkVar(id);
                   String type = Variables.getType(id);
                   RESULT = Translator.getNewTmpVar(type);

                   Arrays.check(id, e);
                   Translator._applyAssign(RESULT, id + "[" + e + "]"); // .assignment() can't digest array expr as of now
               :}
               |
               ID:id LBRACKET expr:e1 RBRACKET ASSIGN expr:e2
               {:
                   Variables.checkVar(id);
                   RESULT = id;

                   Arrays.check(id, e1);
                   e2 = Variables.isChar(e2) ? Char.toInt(e2) : e2;
                   Translator._applyAssign(id + "[" + e1 + "]", e2);
               :}
               |
               ID:id ASSIGN LCURLY init_list:ls RCURLY
               {:
                   Arrays.init(id, ls);
               :}
               |
               ID:id LENGTH_PROP
               {:
                   RESULT = id + "_length";
                   Variables.declareVar(RESULT, "0");
                   // other way is to init id_length when the arr is declared; then when ".length", just RESULT = id + "_length"
                   Translator._applyAssign(RESULT, Variables.getLength(id));
               :}
               ;

// ================================================================
// ======================== COMPARISON OPS ========================

cond ::= expr:e1 EQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, false); :}
         |
         expr:e1 LT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LT, e2, false); :}
         |
         expr:e1 NEQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2, true); :}
         |
         expr:e1 GT expr:e2
         {: RESULT = Translator.comparison(e2, Translator.LT, e1, false); :}
         |
         expr:e1 LE expr:e2
         {:
            Condition eq0 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq0.FalseLabel());
            Condition lt0 = Translator.comparison(e1, Translator.LT, e2, false);
            Translator._label(eq0.TrueLabel());
            Translator._goto(lt0.TrueLabel());
            RESULT = lt0;
         :}
         |
         expr:e1 GE expr:e2
         {:
            Condition eq1 = Translator.comparison(e1, Translator.EQ, e2, false);
            Translator._label(eq1.FalseLabel());
            Condition lt1 = Translator.comparison(e2, Translator.LT, e1, false);
            Translator._label(eq1.TrueLabel());
            Translator._goto(lt1.TrueLabel());
            RESULT = lt1;
         :}
         |
         LPAREN cond:c RPAREN
         {: RESULT = c; :}
         |
         logical:l
         {: RESULT = l; :}
         ;

// ================================================================
// ======================== LOGICAL OPS ===========================

logical ::= NOT cond:c
            {: c.permute(); RESULT = c; :}
            |
            cond:c1 AND
            {: Translator._label(c1.TrueLabel()); :}
            cond:c2
            {:
                Translator._label(c1.FalseLabel());
                Translator._goto(c2.FalseLabel());
                RESULT = c2;
            :}
            |
            cond:c1 OR
            {: Translator._label(c1.FalseLabel()); :}
            cond:c2
            {:
                Translator._label(c1.TrueLabel());
                Translator._goto(c2.TrueLabel());
                RESULT = c2;
            :}
            ;
