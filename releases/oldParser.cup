import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

action code {:
    // Code to be included in the action class - the one that parses the tokens (THESE RULES)
    String init_type = "";
    String else_postpone_false_label = "";
    String else_new_label = "";
:};

parser code {:
    public void report_error(String message, Object info) {
        if(info instanceof Symbol) {
            Symbol curr = (Symbol)info;
            if(curr.left != -1 && curr.right != -1) {
                int line = curr.left + 1;
                int column = curr.right + 1;
                System.err.println(message + "(line " + line + ", column " + column + ")");
            }
        } else {
            System.err.println(message);
        }
        System.err.println(info);
    }
:};


// %%


terminal SEMI, COMMA, PRINT, LPAREN, RPAREN, ASSIGN, LCURLY, RCURLY, LBRACKET, RBRACKET, INT;
terminal PLUS, MINUS, TIMES, MOD, DIV, UMINUS;
terminal EQ, NEQ, LT, GT, LE, GE;
terminal NOT, OR, AND, TRUE, FALSE;
terminal String IF, ELSE;
terminal Condition FOR, DO, WHILE;
terminal String ID, NUMBER;

nonterminal Object statement_list, stmt, if_stmt, else_opt, while_stmt, do_while_stmt, for_stmt;
nonterminal String expr, id_call, var_init_list;
nonterminal Condition cond, logical;

// lowest priority
 precedence right ASSIGN;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left UMINUS;
precedence left AND, OR;
precedence left ELSE;
precedence right NOT;
// highest priority


// %%


statement_list ::= statement_list stmt
                   |
                   stmt
                   ;

stmt ::= INT:t              {: init_type = "int"; :}
         var_init_list SEMI
         |
         expr SEMI
         |
         if_stmt
         |
         while_stmt
         |
         do_while_stmt
         |
         for_stmt
         |
         PRINT expr:e SEMI
         {: Translator._print(e); :}
         |
         LCURLY statement_list RCURLY
         {: /* done in the inner statement list */ :}
         ;


// ================================================================
// ======================== COMPOSED STATEMENTS ===================

if_stmt ::= IF:tagIf LPAREN cond:c RPAREN {: Translator._label(c.TrueLabel()); :}
            stmt                          {: else_postpone_false_label = c.FalseLabel(); :}
            else_opt                      {::}
            ;

else_opt ::= ELSE:tagElse  {:
            else_new_label = Translator.getNewLabel(); // creates a new label for exiting the whole statement
            Translator._goto(else_new_label);
            Translator._label(else_postpone_false_label);
         :}
         stmt          {: Translator._label(else_new_label); :}
         | /* empty */
         {: Translator._label(else_postpone_false_label); :}
         ;


while_stmt ::= WHILE:tagWhile LPAREN {: Translator._label(tagWhile.TrueLabel()); :}
               cond:c RPAREN         {: Translator._label(c.TrueLabel()); :}
               stmt                  {: Translator._goto(tagWhile.TrueLabel()); Translator._label(c.FalseLabel()); :}
               ;


do_while_stmt ::= DO:tagDo                             {: Translator._label(tagDo.TrueLabel()); :}
                  stmt WHILE LPAREN cond:c RPAREN SEMI {: // stmt gets written by itself
                    Translator._label(c.TrueLabel()); /* => */ Translator._goto(tagDo.TrueLabel());
                    Translator._label(c.FalseLabel());
                  :}
                  ;

for_stmt ::= FOR:tagFor LPAREN expr:e1 SEMI {: Translator._label(tagFor.TrueLabel()); :}
             cond:c1 SEMI                   {: Translator._label(c1.TrueLabel()); :}
             expr:e2 RPAREN                 {::}
             stmt                           {: Translator._goto(tagFor.TrueLabel()); Translator._label(c1.FalseLabel()); :}
             ;


// ================================================================
// ======================== ARITHMETIC OPS ========================

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "+", e2); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = Translator.arithmetic(e1, "-", e2); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = Translator.arithmetic(e1, "*", e2); :}
         |
         expr:e1 DIV expr:e2
         {: RESULT = Translator.arithmetic(e1, "/", e2); :}
         |
         expr:e1 MOD expr:e2
         {: RESULT = Translator.arithmetic(e1, "%", e2); :}
         |
         MINUS expr:e
         {: RESULT = Translator.arithmetic("", "-", e); :}
         %prec UMINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         |
         ID:i ASSIGN expr:e // once the variable has already been declared
         {: RESULT = Translator.assignment(i, e); :}
         |
         id_call // just an ID, no assignments or declarations
         |
         NUMBER:n
         {: RESULT = n; :}
         ;

var_init_list ::= var_init_list COMMA ID:i
                  {: RESULT = Translator.initKey(i, init_type); :}
                  |
                  ID:i
                  {: RESULT = Translator.initKey(i, init_type); :}
                  ;
id_call ::= ID:i
            {: RESULT = Translator.getKey(i); :}
            |
            LBRACKET id_call:i RBRACKET
            {: RESULT = i; :}
            ;

// ================================================================
// ======================== COMPARISON OPS ========================

cond ::= expr:e1 EQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.EQ, e2); :}
         |
         expr:e1 NEQ expr:e2
         {: RESULT = Translator.comparison(e1, Translator.NEQ, e2); :}
         |
         expr:e1 LT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LT, e2); :}
         |
         expr:e1 GT expr:e2
         {: RESULT = Translator.comparison(e1, Translator.GT, e2); :}
         |
         expr:e1 LE expr:e2
         {: RESULT = Translator.comparison(e1, Translator.LE, e2); :}
         |
         expr:e1 GE expr:e2
         {: RESULT = Translator.comparison(e1, Translator.GE, e2); :}
         |
         LPAREN cond:c RPAREN
         {: RESULT = c; :}
         |
         logical:l
         {: RESULT = l; :}
         ;

// ================================================================
// ======================== LOGICAL OPS ===========================

logical ::= NOT cond:c
            {: c.permute(); RESULT = c; :}
            |
            cond:c1 AND {: Translator._label(c1.TrueLabel()); :}
            cond:c2     {:
                Translator._label(c1.FalseLabel());
                Translator._goto(c2.FalseLabel());
                RESULT = c2;
            :}
            |
            cond:c1 OR {: Translator._label(c1.FalseLabel()); :}
            cond:c2    {:
                Translator._label(c1.TrueLabel());
                Translator._goto(c2.TrueLabel());
                RESULT = c2;
            :}
            |
            TRUE
            {: RESULT = Translator.comparison("true", Translator.TRUE, ""); :}
            |
            FALSE
            {: RESULT = Translator.comparison("false", Translator.FALSE, ""); :}
            ;
